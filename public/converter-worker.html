<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Converter Worker</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
        }
    </style>
</head>

<body>
    <script type="module">
        import { FFmpeg } from 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/esm/index.js';
        import { fetchFile, toBlobURL } from 'https://unpkg.com/@ffmpeg/util@0.12.1/dist/esm/index.js';

        // FFmpeg instance
        let ffmpeg = null;
        let loaded = false;

        // Load FFmpeg
        async function loadFFmpeg() {
            if (loaded) return true;

            const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm';
            ffmpeg = new FFmpeg();

            ffmpeg.on('log', ({ message }) => {
                console.log('[FFmpeg Worker]', message);
            });

            ffmpeg.on('progress', ({ progress }) => {
                // Send progress to parent
                window.parent.postMessage({
                    type: 'PROGRESS',
                    progress: progress
                }, '*');
            });

            try {
                await ffmpeg.load({
                    coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                    wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                });
                loaded = true;
                console.log('[FFmpeg Worker] Loaded successfully');
                return true;
            } catch (err) {
                console.error('[FFmpeg Worker] Load error:', err);
                return false;
            }
        }

        // Convert video to GIF
        async function convertToGif(videoData, settings) {
            const inputName = 'input.mp4';
            const outputName = 'output.gif';

            // Write file to FFmpeg FS
            await ffmpeg.writeFile(inputName, new Uint8Array(videoData));

            // Construct Filter Complex
            const steps = [];
            let currentTag;

            // Step 1: Trim & Reset PTS
            steps.push(`[0:v]trim=start=${settings.trimStart}:end=${settings.trimEnd},setpts=PTS-STARTPTS[trimmed]`);
            currentTag = '[trimmed]';

            // Step 2: Crop (if exists)
            if (settings.crop) {
                const w = Math.floor(settings.crop.width / 2) * 2;
                const h = Math.floor(settings.crop.height / 2) * 2;
                const x = Math.floor(settings.crop.x / 2) * 2;
                const y = Math.floor(settings.crop.y / 2) * 2;
                steps.push(`${currentTag}crop=${w}:${h}:${x}:${y}[cropped]`);
                currentTag = '[cropped]';
            }

            // Step 3: FPS & Scale
            steps.push(`${currentTag}fps=${settings.fps},scale=${settings.width}:-1:flags=lanczos[scaled]`);
            currentTag = '[scaled]';

            // Step 4: Speed
            steps.push(`${currentTag}setpts=${(1 / settings.speed).toFixed(4)}*PTS[sped]`);
            currentTag = '[sped]';

            // Step 5: Playback Mode
            let finalVideoTag = currentTag;

            if (settings.mode === 'reverse') {
                steps.push(`${currentTag}reverse[outv]`);
                finalVideoTag = '[outv]';
            } else if (settings.mode === 'boomerang') {
                steps.push(`${currentTag}split[fwd][rev]`);
                steps.push(`[rev]reverse[rev_out]`);
                steps.push(`[fwd][rev_out]concat=n=2:v=1:a=0[outv]`);
                finalVideoTag = '[outv]';
            }

            // Palette Generation & Use
            const filterComplexMain = steps.join(';');
            const finalFilterComplex = `${filterComplexMain};${finalVideoTag}split[p_in][g_in];[p_in]palettegen[p];[g_in][p]paletteuse`;

            await ffmpeg.exec([
                '-i', inputName,
                '-filter_complex', finalFilterComplex,
                '-f', 'gif',
                outputName
            ]);

            const data = await ffmpeg.readFile(outputName);

            // Clean up files
            await ffmpeg.deleteFile(inputName);
            await ffmpeg.deleteFile(outputName);

            // Return as ArrayBuffer (Transferable)
            return data.buffer;
        }

        // Listen for messages from parent
        window.addEventListener('message', async (event) => {
            const { type, id, videoData, settings } = event.data;

            if (type === 'LOAD') {
                const success = await loadFFmpeg();
                window.parent.postMessage({
                    type: 'LOAD_RESULT',
                    id,
                    success
                }, '*');
            }

            if (type === 'CONVERT') {
                try {
                    if (!loaded) {
                        await loadFFmpeg();
                    }
                    const result = await convertToGif(videoData, settings);
                    // Use Transferable Objects for zero-copy transfer
                    window.parent.postMessage({
                        type: 'CONVERT_RESULT',
                        id,
                        success: true,
                        data: result
                    }, '*', [result]);
                } catch (err) {
                    window.parent.postMessage({
                        type: 'CONVERT_RESULT',
                        id,
                        success: false,
                        error: err.message
                    }, '*');
                }
            }
        });

        // Notify parent that worker is ready
        window.parent.postMessage({ type: 'WORKER_READY' }, '*');
    </script>
</body>

</html>